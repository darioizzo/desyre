// Copyright 2020, 2021, 2022 Francesco Biscani (bluescarni@gmail.com), Dario Izzo (dario.izzo@gmail.com)
//
// This file is part of the dsyre library.
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.

#ifndef DSYRE_DATA_GENERATION_H
#define DSYRE_DATA_GENERATION_H

#include <boost/math/constants/constants.hpp>
#include <cmath>
#include <random>
#include <vector>

#include <dsyre/detail/visibility.hpp>
#include <dsyre/gym/misc_data.hpp>
#include <dsyre/gym/nist_data.hpp>

namespace dsyre
{
namespace gym
{
namespace detail
{
inline constexpr auto pi = boost::math::constants::pi<double>();
inline constexpr auto e = boost::math::constants::e<double>();

typedef double (*multivar_func_ptr_t)(const std::vector<double> &);

// Standard Problems
inline double koza_quintic(const std::vector<double> &x)
{
    return std::pow(x[0], 5) - 2 * std::pow(x[0], 3) + x[0];
}

// From:
// Izzo, D., Biscani, F., & Mereta, A. (2017, April).
// Differentiable genetic programming.
// In European Conference on Genetic Programming (pp. 35-51). Springer.
inline double P1(const std::vector<double> &x)
{
    return std::pow(x[0], 5) - pi * std::pow(x[0], 3) + x[0];
}

inline double P2(const std::vector<double> &x)
{
    return std::pow(x[0], 5) - pi * std::pow(x[0], 3) + 2. * pi / x[0];
}

inline double P3(const std::vector<double> &x)
{
    return (e * std::pow(x[0], 5) + std::pow(x[0], 3)) / (x[0] + 1.);
}

inline double P4(const std::vector<double> &x)
{
    return sin(pi * x[0]) + 1. / x[0];
}

inline double P5(const std::vector<double> &x)
{
    return e * std::pow(x[0], 5) - pi * std::pow(x[0], 3) + x[0];
}

inline double P6(const std::vector<double> &x)
{
    return (e * x[0] * x[0] - 1) / (pi * (x[0] + 2));
}

inline double P7(const std::vector<double> &x)
{
    return std::cos(pi * x[0]) + std::sin(e * x[0]);
}

// From: PySR example
inline double P8(const std::vector<double> &x)
{
    return 2.5382 * std::cos(x[3]) + x[0] * x[0] - 0.5;
}

// From:
// Vladislavleva, Ekaterina J., Guido F. Smits, and Dick Den Hertog.
// "Order of nonlinearity as a complexity measure for models generated by symbolic regression via pareto genetic
// programming." IEEE Transactions on Evolutionary Computation 13.2 (2008): 333-349.
inline double kotanchek(const std::vector<double> &x)
{
    return std::exp(-(x[0] - 1.) * (x[0] - 1.)) / (1.2 + (x[1] - 2.5) * (x[1] - 2.5));
}

inline double salutowicz(const std::vector<double> &x)
{
    return std::exp(-x[0]) * x[0] * x[0] * x[0] * std::cos(x[0]) * std::sin(x[0])
           * (std::cos(x[0]) * std::sin(x[0]) * std::sin(x[0]) - 1.);
}

inline double salutowicz2d(const std::vector<double> &x)
{
    return salutowicz(x) * (x[1] - 5.);
}

inline double uball5d(const std::vector<double> &x)
{
    return 10.
           / (5.
              + std::pow((x[0] - 3.), 2) * std::pow((x[1] - 3.), 2) * std::pow((x[2] - 3.), 2)
                    * std::pow((x[3] - 3.), 2) * std::pow((x[4] - 3.), 2));
}

inline double ratpol3d(const std::vector<double> &x)
{
    return 30. * (x[0] - 1.) * (x[2] - 1.) / (x[1] * x[1] * (x[0] - 10.));
}

inline double sinecosine(const std::vector<double> &x)
{
    return 6. * std::cos(x[0] * std::sin(x[1]));
}

inline double ripple(const std::vector<double> &x)
{
    return (x[0] - 3.) * (x[1] - 3.) + 2 * std::sin((x[0] - 4.) * (x[1] - 4.));
}

inline double ratpol2d(const std::vector<double> &x)
{
    return (std::pow(x[0] - 3., 4) + std::pow(x[1] - 3., 3) - (x[1] - 3.)) / (std::pow(x[1] - 2, 4.) + 10.);
}

// Generates data to test symbolic regression on 1D input-output cases.
inline void generate_1Ddata(std::vector<std::vector<double>> &points, std::vector<double> &labels,
                            multivar_func_ptr_t f, double lb = -1, double ub = 1, unsigned N = 10)
{
    points.clear();
    labels.clear();
    for (unsigned i = 0u; i < N; ++i) {
        double x = lb + (i * (ub - lb)) / (N - 1);
        points.push_back({x});
        labels.push_back({f({x})});
    }
}
inline void generate_normal_data(std::vector<std::vector<double>> &points, std::vector<double> &labels,
                                 multivar_func_ptr_t f, unsigned N, unsigned m)
{
    std::random_device rd; // only used once to initialise (seed) engine
    std::mt19937 rng(32u); // random-number engine used (Mersenne-Twister in this case)
    std::normal_distribution<double> normal(0., 1.);
    points.clear();
    labels.clear();
    points.resize(N);
    labels.resize(N);
    for (auto &x : points) {
        x.resize(m);
        for (auto &item : x) {
            item = 2 * normal(rng);
        }
    }
    for (auto i = 0u; i < N; ++i) {
        labels[i] = f(points[i]);
    }
}
} // namespace detail
} // namespace gym
} // namespace dsyre
#endif